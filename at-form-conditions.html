<script src="lib/business-rules/conditions-builder.js" type="text/javascript"></script>

<dom-module id="at-form-conditions">
  <style>
    #conditionsHtmlContainer {
      margin: 20px 0;
    }

    #conditionsHtmlContainer > .conditional > .remove {
      display: none;
    }

    .conditional {
      padding-left: 60px;
    }

    .conditional .all-any-none-wrapper {
      margin: 5px 20px 5px -60px;
      display: -moz-inline-stack;
      display: inline-block;
    }

    .all-any-none {
      margin-right: 10px;
    }

    .all-any-none-wrapper,
    .conditional,
    .rule {
      margin: 10px 0;
    }

    .add-rule,
    .add-condition,
    .remove {
      margin: auto 5px;
    }

    .remove {
      color: red;
    }

    .rule input {
      width: 250px;
    }

    .rule select {
      margin-right: 10px;
    }
  </style>
  <template>
    <div>
      <h4>When these conditions are met ...</h4>
    </div>
    <div id="conditionsHtmlContainer"></div>
  </template>
  <script>
    'use strict';
    // ----------------------------------------
    // at-form-conditions definition
    // ----------------------------------------
    Polymer({
      is: 'at-form-conditions',
      properties: {
        schema: {
          type: Object,
          value: function() {
            return {};
          },
          observer: 'schemaChanged'
        },
        config: {
          type: Array,
          value: function() {
            return {};
          },
          observer: 'configChanged',
        },
        value: {
          type: Object,
          value: function() {
            return {
              "all": [] // "all is needed because add rule interface is not displayed if conditions object is empty
            };
          },
          notify: true,
          observer: 'valueChanged'
        },
        disabled: {
          type: Boolean,
          value: false,
          observer: 'disabledChanged'
        }
      },
      _scopeCssViaAttr: true,
      pr_conditionsBuilder: undefined,
      pr_conditionsHtml: undefined,
      _isInternalUpdate: false,
      ready: function() {

      },
      initBuilder: function() {
        var self = this;
        if (!this.pr_conditionsBuilder) {
          this.pr_conditionsBuilder = RuleEngineHelpers.conditionsBuilder.call(this);
          this.pr_conditionsBuilder.on('update', function(updateEvent) {
            // this is microevents solution
            // conditionsBuilder provides for update event
            // update event is fired when (sub)conditions are added / removed / modified
            // self.set('value.conditions', self.collectConditionsData());
            var tmpValue = self.collectConditionsData();

            // this flag is needed to break the infinite loop
            // when internal values of the conditions change value just needs to be set
            // there is no need to recreate the html again
            self._isInternalUpdate = true;
            self.value = tmpValue;

            //self.fire('value-changed', self.value);
          });
        }
      },
      schemaChanged: function(newValue, oldValue) {
        if (this.__conditionsHelperFunctions.isSchemaValid(newValue)) {
          var t_config = this.__conditionsHelperFunctions.schemaToConfig(newValue);
          this.config = t_config.value.fields;
          this.value = t_config.value.data;
        }
      },
      collectConditionsData: function() {
        var conditionsData = this.pr_conditionsBuilder.collectData(this.pr_conditionsHtml);
        return conditionsData;
      },
      configChanged: function(newValue, oldValue) {
        this.initBuilder();
        this.pr_conditionsBuilder.setConditions(newValue);
        this._rebuildConditionsHtml();
      },
      valueChanged: function(newValue, oldValue) {
        if (this._isInternalUpdate) {
          // this flag is needed to break the infinite loop
          // when internal values of the conditions change value just needs to be set
          // there is no need to recreate the html again
          this._isInternalUpdate = false;
          return;
        }
        this.initBuilder();
        this.pr_conditionsBuilder.setData(newValue);
        this._rebuildConditionsHtml();
      },
      _rebuildConditionsHtml: function() {
        this.removeAllChildren(this.$.conditionsHtmlContainer);
        this.pr_conditionsHtml = this.pr_conditionsBuilder.buildConditionsHtml();
        Polymer.dom(this.$.conditionsHtmlContainer).appendChild(this.pr_conditionsHtml);
        this.disabledChanged(this.disabled, this.disabled);
        //this._isInternalUpdate = true;
        //var tmpValue = this.collectConditionsData();
        //this.value = tmpValue;
      },
      disabledChanged: function(newValue, oldValue) {
        var
          selectIndex,
          selectElement,
          selectElements = [],
          inputIndex,
          inputElement,
          inputElements = [],
          aIndex,
          aElement,
          aElements = [],
          tmp;

        if (this.pr_conditionsHtml !== '') {
          tmp = this.pr_conditionsHtml.querySelectorAll('select');
          if (tmp.length > 0) {
            this.pushArray1IntoArray2(tmp, selectElements);
          }
          tmp = this.pr_conditionsHtml.querySelectorAll('input');
          if (tmp.length > 0) {
            this.pushArray1IntoArray2(tmp, inputElements);
          }
          tmp = this.pr_conditionsHtml.querySelectorAll('button');
          if (tmp.length > 0) {
            this.pushArray1IntoArray2(tmp, aElements);
          }
        }

        if (newValue) {
          for (selectIndex = 0; selectIndex < selectElements.length; selectIndex += 1) {
            selectElement = selectElements[selectIndex];
            selectElement.setAttribute('disabled', 'disabled');
          }
          for (inputIndex = 0; inputIndex < inputElements.length; inputIndex += 1) {
            inputElement = inputElements[inputIndex];
            inputElement.setAttribute('disabled', 'disabled');
          }
          for (aIndex = 0; aIndex < aElements.length; aIndex += 1) {
            aElement = aElements[aIndex];
            aElement.setAttribute('disabled', 'disabled');
          }
        } else {
          for (selectIndex = 0; selectIndex < selectElements.length; selectIndex += 1) {
            selectElement = selectElements[selectIndex];
            selectElement.removeAttribute('disabled');
          }
          for (inputIndex = 0; inputIndex < inputElements.length; inputIndex += 1) {
            inputElement = inputElements[inputIndex];
            inputElement.removeAttribute('disabled');
          }
          for (aIndex = 0; aIndex < aElements.length; aIndex += 1) {
            aElement = aElements[aIndex];
            aElement.removeAttribute('disabled');
          }
        }
      },

      removeAllChildren: function(parentElement) {
        for (var i = 0; i < Polymer.dom(parentElement).childNodes.length; i += 1) {
          Polymer.dom(parentElement).removeChild(Polymer.dom(parentElement).childNodes[i]);
        }
      },

      pushArray1IntoArray2: function(array1, array2) {
        var
          arr1Index;

        for (arr1Index = 0; arr1Index < array1.length; arr1Index += 1) {
          array2.push(array1[arr1Index]);
        }
      },

      // ----------------------------------------
      // at-form-conditions helper functions
      // ----------------------------------------
      __conditionsHelperFunctions: {
        // ----------------------------------------
        // validates the schema object
        // schema object must contain property 'properties'
        // ----------------------------------------
        isSchemaValid: function(schema) {
          var
            result = false;

          result = schema.hasOwnProperty('properties');

          return result;
        },
        // ----------------------------------------
        // converts schema to config and data
        // schema object must contain property 'properties'
        // ----------------------------------------
        schemaToConfig: function(schema) {
          var result = {
              value: {
                fields: [],
                data: {
                  "all": {}
                }
              },
              hasErrors: false,
              errors: []
            },
            properties = schema.properties,
            propName, // property name
            propDef, // property definition
            propLabel, // property title
            propType, // property type
            field, // a new field to be added to result.value.fields
            hasCompareTargets, // bool that tells that current property has compare targets
            compareTargets, // for a given field holds other fields whose value can be compared to the given field's value
            indexOfDash // for xtype="code-*"
          ;

          // we want to iterate over all properties of schema.properties
          for (propName in properties) {
            propDef = properties[propName];
            propLabel = this.getPropertyLabel(propName, propDef);

            field = {
              label: propLabel,
              name: propName,
              operators: [],
              options: []
            }

            result.value.fields.push(field);

            // *ij* if its needed to compare fields value against a predefined list of values
            //  propDef needs to have an additional property that will provide the list of values

            propType = this.getPropertyType(propDef);
            compareTargets = this.getCompareTargets(propName, properties);
            hasCompareTargets = compareTargets.length > 0;

            switch (propType) {
              case "string":
                field.operators.push(this.createOperatorDef("is present", "present", "none"));
                field.operators.push(this.createOperatorDef("is blank", "blank", "none"));
                field.operators.push(this.createOperatorDef("includes", "inclues", "text"));
                field.operators.push(this.createOperatorDef("matches regex", "matchesRegex", "text"));

                if (hasCompareTargets) {
                  field.operators.push(this.createOperatorDef("is equal to", "equalTo", "select"));
                  field.operators.push(this.createOperatorDef("it not equal to", "notEqualTo", "select"));
                  field.operators.push(this.createOperatorDef("is less than", "lessThan", "select"));
                  field.operators.push(this.createOperatorDef("is less than or equal to", "lessThanEqual", "select"));
                  field.operators.push(this.createOperatorDef("is greater than", "greaterThan", "select"));
                  field.operators.push(this.createOperatorDef("is greater than or equal to", "greaterThanEqual", "select"));

                  field.options.push(this.createFieldOption("Static", "static", undefined, "text"));
                  field.options.push(this.createFieldOption("Field", "field", compareTargets, "select"));
                } else {
                  field.operators.push(this.createOperatorDef("is equal to", "equalTo", "text"));
                  field.operators.push(this.createOperatorDef("it not equal to", "notEqualTo", "text"));
                  field.operators.push(this.createOperatorDef("is less than", "lessThan", "text"));
                  field.operators.push(this.createOperatorDef("is less than or equal to", "lessThanEqual", "text"));
                  field.operators.push(this.createOperatorDef("is greater than", "greaterThan", "text"));
                  field.operators.push(this.createOperatorDef("is greater than or equal to", "greaterThanEqual", "text"));
                }
                break;
              case "number":
                field.operators.push(this.createOperatorDef("is present", "present", "none"));
                field.operators.push(this.createOperatorDef("is blank", "blank", "none"));

                if (hasCompareTargets) {
                  field.operators.push(this.createOperatorDef("is equal to", "equalTo", "select"));
                  field.operators.push(this.createOperatorDef("it not equal to", "notEqualTo", "select"));
                  field.operators.push(this.createOperatorDef("is less than", "lessThan", "select"));
                  field.operators.push(this.createOperatorDef("is less than or equal to", "lessThanEqual", "select"));
                  field.operators.push(this.createOperatorDef("is greater than", "greaterThan", "select"));
                  field.operators.push(this.createOperatorDef("is greater than or equal to", "greaterThanEqual", "select"));

                  field.options.push(this.createFieldOption("Static", "static", undefined, "text"));
                  field.options.push(this.createFieldOption("Field", "field", compareTargets, "select"));
                } else {
                  field.operators.push(this.createOperatorDef("is equal to", "equalTo", "text"));
                  field.operators.push(this.createOperatorDef("it not equal to", "notEqualTo", "text"));
                  field.operators.push(this.createOperatorDef("is less than", "lessThan", "text"));
                  field.operators.push(this.createOperatorDef("is less than or equal to", "lessThanEqual", "text"));
                  field.operators.push(this.createOperatorDef("is greater than", "greaterThan", "text"));
                  field.operators.push(this.createOperatorDef("is greater than or equal to", "greaterThanEqual", "text"));
                }
                break;
              case "boolean":
                field.operators.push(this.createOperatorDef("is equal to", "equalTo", "select"));
                field.operators.push(this.createOperatorDef("it not equal to", "notEqualTo", "select"));
                var trueFalseOptionsArray = [{
                  name: "true",
                  label: "true"
                }, {
                  name: "false",
                  label: "false"
                }];

                field.options.push(this.createFieldOption("Static", "static", trueFalseOptionsArray, "select"));
                if (hasCompareTargets) {
                  field.options.push(this.createFieldOption("Field", "field", compareTargets, "select"));
                }
                break;
              case "enum":
                field.operators.push(this.createOperatorDef("is present", "present", "none"));
                field.operators.push(this.createOperatorDef("is blank", "blank", "none"));

                var
                  enumOptions = this.getEnumOptions(propDef),
                  hasEnumOptions = enumOptions.length > 0;

                if (hasCompareTargets || hasEnumOptions) {
                  field.operators.push(this.createOperatorDef("is equal to", "equalTo", "select"));
                  field.operators.push(this.createOperatorDef("it not equal to", "notEqualTo", "select"));
                } else {
                  field.operators.push(this.createOperatorDef("is equal to", "equalTo", "text"));
                  field.operators.push(this.createOperatorDef("it not equal to", "notEqualTo", "text"));
                }

                if (hasEnumOptions) {
                  field.options.push(this.createFieldOption("Static", "static", enumOptions, "select"));
                } else {
                  field.options.push(this.createFieldOption("Static", "static", undefined, "text"));
                }
                if (hasCompareTargets) {
                  field.options.push(this.createFieldOption("Field", "field", compareTargets, "select"));
                }

                break;
            }
            // end switch (propType)

          }

          return result;
        },
        // ----------------------------------------
        // calculates what is the label for the property
        // ----------------------------------------
        getPropertyLabel: function(propName, propDef) {
          var result = this.capitalize(propName);

          if (propDef.hasOwnProperty('title') && propDef.title !== '') {
            result = propDef.title;
          } else if (propDef.hasOwnProperty('description' && propDef.description !== '')) {
            result = propDef.description;
          }

          return result;
        },
        // ----------------------------------------
        // calculates what is property's type
        // ----------------------------------------
        getPropertyType: function(propDef) {
          var result = propDef.type;

          if (result === "string" && propDef.hasOwnProperty('xtype') && propDef.xtype !== "") {
            result = propDef.xtype;
            if (result.indexOf('-') != -1) {
              indexOfDash = type.indexOf('-');
              result = type.slice(0, indexOfDash);
            }
          }

          if (result === "string" && (!propDef.hasOwnProperty('xtype') || propDef.xtype === '') && propDef.hasOwnProperty('enum') && this.isArray(propDef.enum)) {
            result = "enum";
          }

          return result;
        },
        // ----------------------------------------
        // for a given property name finds the other properties which value can be compared to this property's value
        // ----------------------------------------
        getCompareTargets: function(propName, properties) {
          var
            result = [],
            sourceDef = properties[propName],
            targetDef = {},
            propNameIndex;

          for (propNameIndex in properties) {
            if (propName !== propNameIndex) { // if names are differenct do the check
              targetDef = properties[propNameIndex];
              if (this.isCompareTarget(sourceDef, targetDef)) {
                result.push({
                  label: this.getPropertyLabel(propNameIndex, targetDef),
                  name: propNameIndex
                });
              }
            }
          }

          return result;
        },
        // ----------------------------------------
        // returns true if sourceDef and targetDef define elements whose value can be compared
        // ----------------------------------------
        isCompareTarget: function(sourceDef, targetDef) {
          if (sourceDef.type !== targetDef.type) {
            // if both have different type they are not compatible
            return false;
          }

          if (sourceDef.xtype === undefined && targetDef.xtype === undefined) {
            // if both are of the same type and do not have xtype and they are compatible
            return true;
          }

          if ((sourceDef.xtype === undefined && targetDef.xtype !== undefined) || (sourceDef.xtype !== undefined && targetDef.xtype === undefined)) {
            // if both have same type but one has xtype and other doesn't they are not compatible
            return false;
          }

          if (sourceDef.xtype !== targetDef.xtype) {
            // if both have same type but different xtypes they are not compatible
            return false;
          }

          // at this point both have the same type and same xtype

          if (sourceDef.xtype === 'enum') {
            // compare xvaluelists
            if (sourceDef.xvaluelist === undefined || targetDef.xvaluelist === undefined || sourceDef.xvaluelist !== targetDef.xvaluelist) {
              // if any of the two doesn't have xvaluelist or xvaluelists are different they are not compatible
              return false;
            }
          } else if (sourceDef.xtype === 'lookup') {
            if (sourceDef.xurl === undefined || targetDef.xurl === undefined || sourceDef.xurl !== targetDef.xurl) {
              // if any of the two doesn't have xurl or xurls are different they are not compatible
              return false;
            }
          } else {
            // xtype is not recognized; return false
            return false;
          }

          // source and target are compatible; return true
          return true;
        },
        getEnumOptions: function(propDef) {
          var
            result = [],
            value, valueList = [""],
            trimedValue, index, length;

          if (propDef.xvaluelist !== undefined && propDef.xvaluelist !== "") {
            valueList = propDef.xvaluelist.split(',');
          } else if (propDef.enum && this.isArray(propDef.enum)) {
            valueList = propDef.enum;
          } else {
            console.log("xvaluelist or enum property not specified for property definition");
            console.log(JSON.stringify(propDef, undefined, ' '));
          }

          length = valueList.length;
          for (index = 0; index < length; index += 1) {
            value = valueList[index];
            trimedValue = value.trim();
            result.push({
              name: trimedValue,
              label: this.capitalize(trimedValue)
            });
          }

          return result;
      },
      // ----------------------------------------
      // creates an operator definition
      // ----------------------------------------
      createOperatorDef: function(label, name, fieldType) {
        var result = {
          label: label,
          name: name,
          fieldType: fieldType
        }

        return result;
      },
      // ----------------------------------------
      // creates a new field option
      // ----------------------------------------
      createFieldOption: function(label, name, options, fieldType) {
        var result = {
          label: label,
          name: name
        };
        if (options !== undefined && this.isArray(options)) {
          result.options = options;
        }
        if (fieldType !== undefined && this.isString(fieldType)) {
          result.fieldType = fieldType;
        }

        return result;
      },
      // ----------------------------------------
      // capitalizes the first letter of a word
      // ----------------------------------------
      capitalize: function(string) {
        return string.charAt(0).toUpperCase() + string.slice(1);
      },
      // ----------------------------------------
      // tests if obj is a javascript array
      // ----------------------------------------
      isArray: function(obj) {
        return Object.prototype.toString.call(obj) === "[object Array]";
      },
      isString: function(obj) {
        return Object.prototype.toString.call(obj) === "[object String]";
      }
    },
    // ----------------------------------------
    // end of at-form-conditions helper functions
    // ----------------------------------------

    // ----------------------------------------
    // at-form-conditions html helper functions
    // ----------------------------------------
    __htmlHelperFunctions: {

    }
    // ----------------------------------------
    // end of at-form-conditions html helper functions
    // ----------------------------------------
    });
    // ----------------------------------------
    // end of at-form-conditions definition
    // ----------------------------------------
  </script>
</dom-module>
